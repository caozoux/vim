rdi, rsi, rdx, rcx, r8, r9。 。当参数为 7 个以上时， 前 6 个与前面一样， 但后面的依次从 "右向左" 放入栈中
= module =
	1. mod -s ip_vs /home/zc/github/cache/kernel-4.18/net/netfilter/ipvs/ip_vs.ko
= list =
	1. net
		1. p net_namespace_list
			a) list -o net.list -s net.ipvs -H 0xffffffff881871f0
	2. block
		a) p super_blocks
		b) list -o super_block.s_list -s super_block.s_id  -s super_block.s_fs_info -s super_block.s_root -H 0xffff9630c7c13000
		c) request_queue and reqest
			a) crash> struct super_block.s_bdev ffff8b341dc23000
				  s_bdev = 0xffff8b2b532b1a40
                  struct block_device.bd_disk	ffff8b341dc23000		
				  struct gendisk.queue 0xffff8b24e7413800
				  queue = 0xffff8a3aa206ba50
			      struct request_queue.queue_ctx 0xffff8a3aa206ba50 
	              struct blk_mq_ctx 0x2c97b6604b80:78			

struct blk_mq_ctx 0x2c97b6604b80:78
	3. dentry
		a) list -o dentry.d_child  -H 0xffff942bdcc42df8 (dentry.d_subdirs   list_add(&dentry->d_child, &parent->d_subdirs);)
			1. 	crash> list -o dentry.d_child  -s dentry.d_name.name -H  0xffff942b943c7438
					ffff942b943e4218
					  d_name.name = 0xffff942b943e4250 "33"
					ffff942b943e7de8
					  d_name.name = 0xffff942b943e7e20 "22"
	4. inode
		a)  struct inode.i_dentry  ffff96af2ecef728
			1.  struct dentry.d_u -x
				struct dentry {
					 union {
					  [0xb0] } d_u;
				}
				struct inode.i_dentry  ffff96af2ecef728
				i_dentry = {
				  first = 0xffff96aded8005f0
				}
			2.  0xffff96aded8005f0 - 0xb0 = struct dentry 0xffff96aded800540 
= tree =
	1. tree -t radix -r address_space.page_tree ffff88012d364de0
	2. tree -t xarray -r address_space.i_pages   0xffff96af2ecef8a0
	3. tree -t x -N 0xffff94c23c1566ca -s page.flags,_refcount -x
		1. address_space.i_pages 0xffff94c235e76828
			1. crash> address_space.i_pages 0xffff94c235e76828
				  i_pages = {
					... [ xa_lock field not shown ] ...
					xa_flags = 1, 
					xa_head = 0xffff94c23c1566ca
				  }
				crash> tree -t x -N 0xffff94c23c1566ca
				fffffcc005aa8380
			2. tree -t x -N 0xffff94c23c1566ca -s page.flags,_refcount -x
		2. 	
= gdb  =
	* gdb module as addrline
		1. list *(some_function+0x12c)
		2. 
= vmlinux  =
	* get source line (xt_replace_table+0x96)
	* gdb vmlinux -> dis xt_replace_table 得到 -》0xffffffff816ad736 <+150>:	mov    %rax,(%r14)
	* addr2line -f -e cache/kernel-4.18/vmlinux 0xffffffff816ad736 -> /home/zc/github/kernel-4.18.0/net/netfilter/x_tables.c:1328
	
= cmd =
== kmem ==
	1. kmem address
		1. crash> kmem  ffff942c4d0ddbd8
				  PAGE       PHYSICAL      MAPPING       INDEX CNT FLAGS
			fffff5a4c4343740 10d0dd000 dead000000000400        1  0 17ffffc0000000
		2. crash> kmem -p ffff968781e29f38 ===> get page of the address
					  PAGE         PHYSICAL      MAPPING       INDEX CNT FLAGS
				ffffe0b05f078a40 57c1e29000 ffff96707ae776b0     3cd9  1 57ffffc0000028 uptodate,lru
		3. crash> kmem -g ffffe0b05f078a40 
					FLAGS: ffffe0b05f078a40
					  PAGE-FLAG       BIT  VALUE
					  PG_active         6  0000040
					  PG_owner_priv_1   9  0000200
					  PG_reserved      11  0000800
					  PG_head          15  0008000
					  PG_mappedtodisk  16  0010000
					  PG_reclaim       17  0020000
					  PG_swapbacked    18  0040000
					  PG_idle          24  1000000
					  PG_workingset    25  2000000
					  PG_checked        9  0000200
					  PG_swapcache      9  0000200
					  PG_pinned         9  0000200
					  PG_foreign        9  0000200
					  PG_isolated      17  0020000
== list ==
	* -h list -o xt_table.list  -s xt_table.name -h 0xffffa0c4d7992be8
	* -H  list -o net.list -s net.ipvs -H 0xffffffff881871f0
		1. p net_namespace_list 这个是指针头部，地址是0xffffffff881871f0
	* -H  list -o net.list -s net.ipvs -H 0xffffffff881871f0
	* list -o rwsem_waiter.list -s rwsem_waiter.type -h 0xffffb9cbc15c3dc0

== search ==
== sym ==
== page to virtual==
	1. kmem -p 0xffffea000d973f70
		PAGE        PHYSICAL      MAPPING       INDEX CNT FLAGS
		ffffea000d973f70 3e2122000 ffff88042731f1f8        0  1 400000000800d8
	2. ptov 3e2122000
		VIRTUAL           PHYSICAL
		ffff8803e2122000  3e2122000 

== bt ==
	1. bt -p
	2. bt -p pid -f 线上每个函数的sp栈数据kca
== percpu ==
	* 获取每个cpu变量的基址
		1. kmem -o
			1. CPU 0: ffff8f0080200000
			2. CPU 1: ffff8f0080240000
			3. CPU 2: ffff8f0080280000
			4. CPU 3: ffff8f00802c0000
			5. CPU 42: ffff8f313f400000
		2. struct kmem_cash.cpu_slub
			  crash> struct kmem_cache.cpu_slab 0xffff8ed2070aadc0 -x
			  cpu_slab = 0x2b4c0		
			a) 	
		3. struct kmem_cash.cpu_slub:42 =  ffff8f313f400000 + 0x2b4c0

== makedumpfile ==
	1.  sudo makedumpfile -c -d 31 /proc/kcore  dumpfile

===crash_struct_cmd===
[[kernfs_crash_command]]
== extern ==
=== install ===
	1. yum install crash crash-trace-command
	2. crash>  extend /usr/lib64/crash/extensions/trace.so
	3. https://access.redhat.com/solutions/239433
=== usage ===
	1. trace show 
	2. 
== asm ==	
	[[asm_x86]]	
