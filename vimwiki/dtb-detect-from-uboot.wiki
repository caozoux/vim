void __init setup_arch(char **cmdline_p)
const struct machine_desc *mdesc; 




const struct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)
{
	const struct machine_desc *mdesc, *mdesc_best = NULL;

	if (!dt_phys || !early_init_dt_scan(phys_to_virt(dt_phys)))
		return NULL;

	mdesc = of_flat_dt_match_machine(mdesc_best, arch_get_next_mach);

	if (!mdesc) { 
		出错处理
	}

	/* Change machine number to match the mdesc we're using */
	__machine_arch_type = mdesc->nr;

	return mdesc;
}



bool __init early_init_dt_scan(void *params)
{
	if (!params)
		return false;

	/* 全局变量initial_boot_params指向了DTB的header*/
	initial_boot_params = params;

	/* 检查DTB的magic，确认是一个有效的DTB */
	if (be32_to_cpu(initial_boot_params->magic) != OF_DT_HEADER) {
		initial_boot_params = NULL;
		return false;
	}

	/* 扫描 /chosen node，保存运行时参数（bootargs）到boot_command_line，此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中 */
	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);

	/* 扫描根节点，获取 {size,address}-cells信息，并保存在dt_root_size_cells和dt_root_addr_cells全局变量中 */
	of_scan_flat_dt(early_init_dt_scan_root, NULL);

	/* 扫描DTB中的memory node，并把相关信息保存在meminfo中，全局变量meminfo保存了系统内存相关的信息。*/
	of_scan_flat_dt(early_init_dt_scan_memory, NULL);

	return true;
}

三、初始化流程


    static void __unflatten_device_tree(struct boot_param_header *blob,－－－需要扫描的DTB
                     struct device_node **mynodes,－－－－－－－－－global list指针
                     void * (*dt_alloc)(u64 size, u64 align))－－－－－－内存分配函数
    {
        unsigned long size;
        void *start, *mem;
        struct device_node **allnextp = mynodes;

        此处删除了health check代码，例如检查DTB header的magic，确认blob的确指向一个DTB。

        /* scan过程分成两轮，第一轮主要是确定device-tree structure的长度，保存在size变量中 */
        start = ((void *)blob) + be32_to_cpu(blob->off_dt_struct);
        size = (unsigned long)unflatten_dt_node(blob, 0, &start, NULL, NULL, 0);
        size = ALIGN(size, 4);

        /* 初始化的时候，并不是扫描到一个node或者property就分配相应的内存，实际上内核是一次性的分配了一大片内存，这些内存包括了所有的struct device_node、node name、struct property所需要的内存。*/
        mem = dt_alloc(size + 4, __alignof__(struct device_node));
        memset(mem, 0, size);

        *(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);   //用来检验后面unflattening是否溢出

        /* 这是第二轮的scan，第一次scan是为了得到保存所有node和property所需要的内存size，第二次就是实打实的要构建device node tree了 */
        start = ((void *)blob) + be32_to_cpu(blob->off_dt_struct);
        unflatten_dt_node(blob, mem, &start, NULL, &allnextp, 0); 
       

        此处略去校验溢出和校验OF_DT_END。
    }


