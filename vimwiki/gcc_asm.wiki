  asm("汇编语句"
  　　:输出寄存器
  　　:输入寄存器
  　　:会被修改的寄存器);
  
 、    指定输出值
            __asm__ __volatile__ (
                    "asm code"
                    :“constraint”（variable）
            );
    
            constraint定义variable的存放位置：
                                r            使用任何可用的通用寄存器
                                m            使用变量的内存地址

            output修饰符：
                                +            可读可写
                                =            只写
                                &            该输出操作数不能使用输入部分使用过的寄存器，只能 +& 或 =& 方式使用
                                
    2、    指定输入值
            __asm__ __volatile__ (
                    "asm code"
                    :
                    :“constraint”（variable / immediate）
            );
    
            constraint定义variable / immediate的存放位置：
                                r            使用任何可用的通用寄存器（变量和立即数都可以）
                                m            使用变量的内存地址（不能用立即数）
                                i             使用立即数（不能用变量）
                    
    3、    使用占位符
            int a = 100,b = 200;
            int result;
            __asm__ __volatile__ (
                    “mov    %0,%3/n/t”        //mov     r3,#123                %0代表result，%3代表123（编译器会自动加 # 号）
                    “ldr    r0,%1/n/t”        //ldr     r0,[fp, #-12]        %1代表 a 的地址
                    “ldr    r1,%2/n/t”        //ldr     r1,[fp, #-16]        %2代表 b 的地址
                    “str    r0,%2/n/t”        //str     r0,[fp, #-16]        因为%1和%2是地址所以只能用ldr或str指令
                    “str    r1,%1/n/t”        //str     r1,[fp, #-12]        如果用错指令编译时不会报错，要到汇编时才会
                    ：“=r”(result),“+m”(a),“+m”(b)                            out1是%0，out2是%1，...，outN是%N-1
                    ：“i”(123)                                                    in1是%N，in2是%N+1，...
            );
