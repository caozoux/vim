start
awkenv_var
		$n	当前记录的第n个字段，字段间由FS分隔。
		$0	完整的输入记录。
		ARGC	命令行参数的数目。
		ARGIND	命令行中当前文件的位置(从0开始算)。
		ARGV	包含命令行参数的数组。
		CONVFMT	数字转换格式(默认值为%.6g)
		ENVIRON	环境变量关联数组。
		RRNO	最后一个系统错误的描述。
		FIELDWIDTHS	字段宽度列表(用空格键分隔)。
		FILENAME	当前文件名。
		FNR	同NR，但相对于当前文件。
		FS	字段分隔符(默认是任何空格)。
		IGNORECASE	如果为真，则进行忽略大小写的匹配。
		NF	当前记录中的字段数。
		NR	当前记录数。
		OFMT	数字的输出格式(默认值是%.6g)。
		OFS	输出字段分隔符(默认值是一个空格)。
		ORS	输出记录分隔符(默认值是一个换行符)。
		RLENGTH	由match函数所匹配的字符串的长度。
		RS	记录分隔符(默认是一个换行符)。
		RSTART	由match函数所匹配的字符串的第一个位置。
		SUBSEP	数组下标分隔符(默认值是\034)。
awkoperate
		= += -= *= /= %= ^= **=	赋值
		?:	C条件表达式
		||	逻辑或
		&&	逻辑与
		~ ~!	匹配正则表达式和不匹配正则表达式
		< <= > >= != ==	关系运算符
		空格	连接
		+ -	加，减
		* / &	乘，除与求余
		+ - !	一元加，减和逻辑非
		^ ***	求幂
		++ --	增加或减少，作为前缀或后缀
		$	字段引用
		in	数组成员
getopts
		$OPTARG 当前参数
		$OPTIND 下标
sed
		shell#sed1	sed 's/test/mytest/g' example$ sed '2d' example-----删除example文件的第二行。  
		shell#sed2	sed '2,$d' example-----删除example文件的第二行到末尾所有行。  
		shell#sed3	sed '$d' example-----删除example文件的最后一行。  
		shell#sed4	sed '/test/'d example-----删除example文件所有包含test的行。  
		shell#sed5	sed 's/test/mytest/g' example-----在整行范围内把test替换为mytest。如果没有g标记，则只有每行第一个匹配的test被替换成mytest。  
		shell#sed6	sed -n 's/^test/mytest/p' example-----(-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说，如果某一行开头的test被替换成mytest，就打印它。  
		shell#sed7	sed 's/^192.168.0.1/&localhost/' example-----&符号表示替换换字符串中被找到的部份。所有以192.168.0.1开头的行都会被替换成它自已加 localhost，变成192.168.0.1localhost。  
		shell#sed8	sed -n 's/\(love\)able/\1rs/p' example-----love被标记为1，所有loveable会被替换成lovers，而且替换的行会被打印出来。  
		shell#sed9	sed 's#10#100#g' example-----不论什么字符，紧跟着s命令的都被认为是新的分隔符，所以，“#”在这里是分隔符，代替了默认的“/”分隔符。表示把所有10替换成100。 选定行的范围：逗号  
		shell#sed10	sed -n '/test/,/check/p' example-----所有在模板test和check所确定的范围内的行都被打印。  
		shell#sed11	sed -n '5,/^test/p' example-----打印从第五行开始到第一个包含以test开始的行之间的所有行。  
		shell#sed12	sed '/test/,/check/s/$/sed test/' example-----对于模板test和west之间的行，每行的末尾用字符串sed test替换。多点编辑：e命令
		shell#sed13	sed -e '1,5d' -e 's/test/check/' example-----(-e)选项允许在同一行里执行多条命令。如例子所示，第一条命令删除1至5行，第二条命令用check替换test。命令的执 行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。  
		shell#sed14	sed --expression='s/test/check/' --expression='/love/d' example-----一个比-e更好的命令是--expression。它能给sed表达式赋值。
		shell#sed15	sed '/test/r file' example-----file里的内容被读进来，显示在与test匹配的行后面，如果匹配多行，则file的内容将显示在所有匹配行的下面。  
		shell#sed16	sed -n '/test/w file' example-----在example中所有包含test的行都被写入file里。  
		shell#sed17	sed '/^test/a\\--->this is a example' example<-----'this is a example'被追加到以test开头的行后面，sed要求命令a后面有一个反斜杠。  
		shell#sed18	sed '/test/i\\  
		-------------------------' example  
		shell#sed19	sed '/test/{ n; s/aa/bb/; }' example-----如果test被匹配，则移动到匹配行的下一行，替换这一行的aa，变为bb，并打印该行，然后继续。  
		shell#sed20	sed '1,10y/abcde/ABCDE/' example-----把1--10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令。  
		shell#sed21	sed '10q' example-----打印完第10行后，退出sed。  
		shell#sed22	sed -e '/test/h' -e '$G example-----在sed处理文件的时候，每一行都被保存在一个叫模式空间的临时缓冲区中，除非行被删除或者输出被取消，否则所有被处理的行都将 打印在屏幕上。接着模式空间被清空，并存入新的一行等待处理。在这个例子里，匹配test的行被找到后，将存入模式空间，h命令将其复制并存入一个称为保 持缓存区的特殊缓冲区内。第二条语句的意思是，当到达最后一行后，G命令取出保持缓冲区的行，然后把它放回模式空间中，且追加到现在已经存在于模式空间中 的行的末尾。在这个例子中就是追加到最后一行。简单来说，任何包含test的行都被复制并追加到该文件的末尾。  
		shell#sed23	sed -e '/test/h' -e '/check/x' example -----互换模式空间和保持缓冲区的内容。也就是把包含test与check的行互换。  

env
		$? 获取返回值

cutstring
		echo ${var#*//} 其中 var 是变量名，# 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符即删除 http://
		echo ${var##*/} ##*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符即删除 http://www.aaa.com/, 123.htm
		echo ${var%/*} %/* 表示从右边开始，删除第一个 / 号及右边的字符结果是：http://www.aaa.com
		echo ${var%%/*} %%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符结果是：http:
		echo ${var:0:5} 其中的 0 表示左边第一个字符开始，5 表示字符的总个数。结果是：http:
		echo ${var:0-7:3}其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数结果是：123
		echo ${var:0-7}表示从右边第七个字符开始，一直到结束。结果是：123.htm
data
		arr_number=(1 2 3 4 5); 一对括号表示数组，数组中元素之间使用"空格"来隔开
		${#arr_number[@]} 长度
		清除某个元素：unset arr_number[1]，这里清除下标为1的数组
		清空整个数组：unset arr_number;
		分片访问${arr_number[@]:1:4}，这里分片访问从下标为1开始，元素个数为4
		for v in ${arr_number[@]}; do
end
